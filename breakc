#!/bin/bash

# 自动破C段工具
# 功能：对IP文件进行排序，并根据相邻IP的差值进行补全

usage() {
    echo "用法: $0 -l 输入文件 [-o 输出文件]"
    echo "选项:"
    echo "  -l, --list    输入文件，包含IP地址列表"
    echo "  -o, --output  输出文件（可选，默认输出到控制台）"
    echo "  -h, --help    显示此帮助信息"
    echo ""
    echo "示例:"
    echo "  $0 -l ip_list.txt -o result.txt"
    echo "  $0 -l ip_list.txt"
    echo ""
    echo "说明:"
    echo "  程序会对IP进行排序，当相邻IP的最后一个字节差值不超过6时进行补全"
    echo "  例如: 192.168.1.1 和 192.168.1.7 会补全为 192.168.1.1-192.168.1.7"
}

# 初始化变量
INPUT_FILE=""
OUTPUT_FILE=""

# 解析命令行参数
while [[ $# -gt 0 ]]; do
    case $1 in
        -l|--list)
            INPUT_FILE="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "错误: 未知参数 $1"
            usage
            exit 1
            ;;
    esac
done

# 检查必要参数
if [[ -z "$INPUT_FILE" ]]; then
    echo "错误: 必须指定输入文件"
    usage
    exit 1
fi

if [[ ! -f "$INPUT_FILE" ]]; then
    echo "错误: 输入文件不存在: $INPUT_FILE"
    exit 1
fi

# 临时文件
TEMP_SORTED=$(mktemp)
TEMP_RESULT=$(mktemp)

# 清理函数
cleanup() {
    rm -f "$TEMP_SORTED" "$TEMP_RESULT"
}
trap cleanup EXIT

# IP地址转数字函数
ip_to_int() {
    local ip="$1"
    local a b c d
    IFS='.' read -r a b c d <<< "$ip"
    echo $((a * 256 * 256 * 256 + b * 256 * 256 + c * 256 + d))
}

# 数字转IP地址函数
int_to_ip() {
    local int="$1"
    echo "$(( (int >> 24) & 255 )).$(( (int >> 16) & 255 )).$(( (int >> 8) & 255 )).$(( int & 255 ))"
}

# 排序IP地址
sort_ips() {
    local temp_file=$(mktemp)
    
    while IFS= read -r ip; do
        if [[ -n "$ip" ]]; then
            ip_to_int "$ip"
        fi
    done < "$INPUT_FILE" | sort -n | while read -r int_ip; do
        int_to_ip "$int_ip"
    done > "$temp_file"
    
    echo "$temp_file"
}

# 主处理函数
process_ips() {
    local previous_ip=""
    local previous_int=0
    local current_network=""
    local start_ip=""
    local end_ip=""
    
    while IFS= read -r current_ip; do
        if [[ -z "$current_ip" ]]; then
            continue
        fi
        
        current_int=$(ip_to_int "$current_ip")
        current_network=$(echo "$current_ip" | cut -d. -f1-3)
        
        # 如果是第一个IP
        if [[ -z "$previous_ip" ]]; then
            start_ip="$current_ip"
            end_ip="$current_ip"
            previous_ip="$current_ip"
            previous_int="$current_int"
            continue
        fi
        
        previous_network=$(echo "$previous_ip" | cut -d. -f1-3)
        diff=$((current_int - previous_int))
        
        # 检查是否属于同一C段且差值不超过6
        if [[ "$current_network" == "$previous_network" && $diff -le 6 && $diff -gt 0 ]]; then
            end_ip="$current_ip"
        else
            # 输出前一段的结果
            if [[ "$start_ip" == "$end_ip" ]]; then
                echo "$start_ip"
            else
                # 生成连续IP范围
                generate_ip_range "$start_ip" "$end_ip"
            fi
            
            # 开始新的段
            start_ip="$current_ip"
            end_ip="$current_ip"
        fi
        
        previous_ip="$current_ip"
        previous_int="$current_int"
    done < "$1"
    
    # 输出最后一段
    if [[ -n "$start_ip" ]]; then
        if [[ "$start_ip" == "$end_ip" ]]; then
            echo "$start_ip"
        else
            generate_ip_range "$start_ip" "$end_ip"
        fi
    fi
}

# 生成IP范围
generate_ip_range() {
    local start_ip="$1"
    local end_ip="$2"
    local start_int=$(ip_to_int "$start_ip")
    local end_int=$(ip_to_int "$end_ip")
    
    for ((i = start_int; i <= end_int; i++)); do
        int_to_ip "$i"
    done
}

# 主程序
echo "开始处理IP文件: $INPUT_FILE"
echo "排序IP地址..."

# 排序IP
SORTED_FILE=$(sort_ips)

echo "分析IP段并补全..."

# 处理IP并生成结果
process_ips "$SORTED_FILE" > "$TEMP_RESULT"

# 输出结果
if [[ -n "$OUTPUT_FILE" ]]; then
    cp "$TEMP_RESULT" "$OUTPUT_FILE"
    echo "结果已保存到: $OUTPUT_FILE"
    echo "总共生成 $(wc -l < "$TEMP_RESULT") 个IP地址"
else
    echo "处理结果:"
    cat "$TEMP_RESULT"
    echo ""
    echo "总共生成 $(wc -l < "$TEMP_RESULT") 个IP地址"
fi

# 清理临时文件
rm -f "$SORTED_FILE"
